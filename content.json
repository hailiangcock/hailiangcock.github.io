{"meta":{"title":"HL,Blog","subtitle":"技术博客","description":"study","author":"hailiangcock","url":"//hailiangcock.github.io","root":"/"},"pages":[{"title":"","date":"2019-06-13T15:45:31.398Z","updated":"2019-06-13T15:45:31.343Z","comments":true,"path":"about/index.html","permalink":"//hailiangcock.github.io/about/index.html","excerpt":"","text":"关于我从事 Android 开发 关于工作城市：上海 喜欢大胸是本能，喜欢平胸才是审美"}],"posts":[{"title":"Dart","slug":"Dart","date":"2019-08-20T16:44:24.299Z","updated":"2019-08-20T16:44:24.299Z","comments":true,"path":"2019/08/21/Dart/","link":"","permalink":"//hailiangcock.github.io/2019/08/21/Dart/","excerpt":"","text":"Dart基础知识 程序入口 控制台输出 变量 检查null或零 Functions 异步编程 Futures async和await 程序入口 JavaScript没有预定义的入口函数，但在Dart中，每个app都必须有一个顶级的main ()函数作为应用程序的入口点(这个跟java很类似)。 12 //Dart main() &#123;&#125; 控制台输出要在Dart中打印到控制台，可使用print : 1234// JavaScriptconsole.log(&quot;Hello world!&quot;); //Dartprint(&apos;Hello world!&apos;); 变量Dart是类型安全的 - 它使用静态类型检查和运时的组合，检查以确保变量的值始终与变量的静态值匹配类型。 尽管类型是必需的，但某些类型注释是可选的，因为Dart会执行类型推断。 12345// JavaScriptvar name = &quot;DavaScript&quot;;//DartString name = &apos;dart&apos;; // Explicitly typed as a string, var otherName = &apos;Dart&apos;; // Inferred string. 在JavaScript中，未初始化的变量是undefined;在Dart中，未初始化的变畺的初始值为null。注意：数宇在Dart中也被当成对象，所以只要是带有数宇类型的末初始化变畺的值都是“null”。 1234// JavaScriptvan name; // == undefined// Dartvan name; // == null 检查null或零在JavaScript中，1或任何非null对象的值被视为true 12345678// JavaScript van myNull = null; if (SmyNull) &#123;console.log&#123;&quot;null is treated as false.’） ；&#125;van zero = 0; if (!zeno) &#123;console.log(M0 is treated as false&quot;); 在Dart中，只有布尔值“true”被视为true。 12345678//Dartvar myNull = null; if (myNull == null) &#123;print(&apos;use &quot;== null&quot; to check null&apos;);&#125;var zero = 0; if (zero == 0) &#123;print(&apos;use &quot;== 0&quot; to check zero&apos;); Dart null检查最佳实践从Dart 1.12开始，null-aware运算符可用帮助我们做null检查： 12345bool isConnected(a, b) &#123; bool outConn = outgoing[a]?.contains(b) ?? false; bool inConn = incoming[a]?.contains(b) ?? false; return outConn || inConn;&#125; ?. 运算符在左边为null的情况下会阻断右边的调用，？？运算符主要作用是在左侧表达式为null时为其设置默认值。对于表达式： 1outgoing[a]?.contains(b) 可以计算下面结果 123print(null ?? false);print(false ?? 11);print(true ?? false); Functions123456789101112// JavaScript ES6 function fn() &#123; return true;&#125;//Dart fn() &#123; return true;&#125;// can also be written as bool fn() &#123; return true;&#125; 异步编程Futures与JavaScript一样，Dart支持单线程执行。在javaScript中 Promise 对象表示异步操作的最终完成或者失败及其结果值。Dart使用Future表示异步操作： 12345678910111213141516171819// JavaScript_getIPAddress = () =&gt;&#123; const url = &quot;https://httpbin.org/ip&quot;; return fetch() .then(response =&gt; response.json()) .then(responseJson =&gt; &#123; console.log(responseJson.origin); &#125;) .catch(error =&gt; &#123; console.error(error); &#125;);&#125;;// Dart_getIPAddress() &#123; final url = &quot;https://httpbin.org/ip&quot;; HttpRequest.request(url).then((value)&#123; print(json.decode(value.responseText)[&apos;origin&apos;]) &#125;).catchError((error) =&gt; pront(error));&#125; async和awaitasync 函数声明定义了一个异步函数。在 JavaScript 中，async函数返回一个Promise。 await 运算符是用来等待 Promise: 12345678// JavaScript_getIPAddress = () =&gt;&#123; const url = &quot;https://httpbin.org/ip&quot;; const response = await fetch(url); const json = await response.json(); const data = await json.origin; console.log(data);&#125;; 在Dart，async 函数返回一个Future，函数的主题是稍后执行。await运算符用于等待Future: 1234567// Dart_getIPAddress() &#123; final url = &quot;https://httpbin.org/ip&quot;; var request = await HttpRequest.request(url); String ip = json.decode(request.responseText)[&apos;origin&apos;]; print(ip);&#125; 参考链接 ：Dart中文网","categories":[],"tags":[]}]}